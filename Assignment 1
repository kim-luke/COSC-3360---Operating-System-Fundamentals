/*
	Luke Kim - 1478875
	COSC 3360: Fundamentals of Operating Systems â€“ Assignment 1
	Due: February 12, 2020 (extended to the 19th)

	This program will simulate the execution of processes of a tablet with a
	multi-core processing unit, one solid-state drive, one display, and a large memory.
	The program will take in file inputs full of processes and output the total simulation time,
	number of processes completed, total number of SSD accesses, average number of busy cores,
	and the SSD utilization (fraction of time that the device was busy).
*/

#include <iostream>
#include <string>
#include <fstream>
#include <queue>
using namespace std;

struct node {
	node* next;
	node* down;
	string start;
	int data;
	int processID;
};

// A linked list that will store nodes that contain the process (word) and time (value)
class eventList {
private:
	node* head;
	node* rear;

public:
	eventList() {
		head = rear = nullptr;
	}

	node* getHead() {
		return head;
	}

	void storeEntry(string word, int value) {
		node* temp = new node;
		temp->start = word;
		temp->data = value;
		temp->next = nullptr;
		temp->down = nullptr;

		if (head == nullptr) {
			head = rear = temp;
			return;
		}

		if (word == "START") {
			rear->next = temp;
			rear = temp;
		}

		else {
			node* bottom = rear;
			while (bottom->down != nullptr) {
				bottom = bottom->down;
			}
			bottom->down = temp;
		}
	}

	void printList() {
		node* cu = head;
		while (cu != nullptr) {
			node* bottom = cu;
			while (bottom != nullptr) {
				cout << bottom->start << " " << bottom->data << endl;
				bottom = bottom->down;
			}
			cu = cu->next;
		}
	}

	void sortList(queue<node*> &sortQueue) {
		node* cu = head;
		while (cu != nullptr) {
			node* bottom = cu;
			if (cu->start == "START") {
				sortQueue.push(cu);
			}

			while (bottom != nullptr) {
				bottom = bottom->down;
			}
			cu = cu->next;
		}
	}

	void assignProcessID() {
		node* cu = head;
		int storePID = 0;

		while (cu != nullptr) {
			node* bottom = cu;

			if (cu->start == "START") {
				cu->processID = cu->down->data;
			}

			while (bottom != nullptr) {

				/*if (bottom->start == "PID") {
					storePID = bottom->data;
				}
				
				else {
					bottom->processID = storePID;
				}
				bottom = bottom->down;*/

				if (bottom->start != "PID") {
					bottom = bottom->down;
				}

				else {
					storePID = cu->data;

					if (bottom->start != "START") {
						bottom->processID = storePID;
					}

					bottom = bottom->down;
				}
			}
			cu = cu->next;
		}


	}
};

void showQueue(queue<node*> sortQueue)
{
	queue<node*> popQueue = sortQueue;
	while (!popQueue.empty())
	{
		cout << popQueue.front()->start << " " << popQueue.front()->data << " " << popQueue.front()->processID << " ";
		popQueue.pop();
	}
	cout << endl;
}

int main() {

	string word;
	int value, numCores;
	int time = 0;
	eventList eventTable;

	ifstream inFile;
	inFile.open("myinput2.txt");
	while (inFile >> word >> value) {
		if (word == "NCORES") {
			numCores = value;
		}

		else {
			eventTable.storeEntry(word, value);
		}
	}

	queue<node*> sortQueue;
	queue<node*> interactQueue;
	queue<node*> nonInteractQueue;

	eventTable.printList();
	eventTable.sortList(sortQueue);
	eventTable.assignProcessID();
	showQueue(sortQueue);

	inFile.close();
	system("pause");
	return 0;
}
