/*
	Luke Kim - 1478875
	COSC 3360: Fundamentals of Operating Systems â€“ Assignment 1
	Due: February 12, 2020 (extended to the 19th)

	This program will simulate the execution of processes of a tablet with a
	multi-core processing unit, one solid-state drive, one display, and a large memory.
	The program will take in file inputs full of processes and output the total simulation time,
	number of processes completed, total number of SSD accesses, average number of busy cores,
	and the SSD utilization (fraction of time that the device was busy).
*/

#include <iostream>
#include <string>
#include <fstream>
#include <queue>
using namespace std;

struct node {
	node* next;
	node* down;
	string start;
	int data;
	int processID;
};

class eventList {
private:
	node* head;
	node* rear;

public:
	eventList() {
		head = rear = nullptr;
	}

	node* getHead() {
		return head;
	}

	// Reads in a string and an int value from the file one line at a time and stores in nodes
	void storeEntry(string word, int value) {
		
		// Creates a new node, settings its next and down connections to null
		// Also sets its start and data value to the string and int value passed in
		node* temp = new node;
		temp->start = word;
		temp->data = value;
		temp->next = nullptr;
		temp->down = nullptr;
		
		if (head == nullptr) {
			head = rear = temp;
			return;
		}

		// When the string passed in is START, we will traverse the linked list to the right rather than down
		if (word == "START") {
			rear->next = temp;
			rear = temp;
		}
		
		// Otherwise create a node that moves downward, creating a 2D list
		else {
			node* bottom = rear;
			while (bottom->down != nullptr) {
				bottom = bottom->down;
			}
			bottom->down = temp;
		}
	}

	void printList() {
		node* cu = head;
		while (cu != nullptr) {
			node* bottom = cu;
			while (bottom != nullptr) {
				cout << bottom->start << " " << bottom->data << endl;
				bottom = bottom->down;
			}
			cu = cu->next;
		}
	}

	// Sorts all nodes that don't contain the word PID
	void filterList(queue<node*> &filteredQueue) {
		node* cu = head;
		while (cu != nullptr) {
			node* bottom = cu;

			while (bottom != nullptr) {

				if (bottom->start != "PID") {
					filteredQueue.push(bottom);
					bottom = bottom->down;
				}

				else {
					bottom = bottom->down;
				}
			}
			cu = cu->next;
		}
	}

	// Assigns ProcessIDs for all nodes in order to differentiate and sort them later
	void assignProcessID() {
		node* cu = head;
		int storePID = 0;

		while (cu != nullptr) {
			node *bottom = cu;

			while (bottom != nullptr) {

				if (bottom->start == "START") {
					bottom->processID = bottom->down->data;
					bottom = bottom->down;
				}

				else if (bottom->start == "PID") {
					storePID = bottom->data;
					bottom = bottom->down;
				}

				else {
					bottom->processID = storePID;
					bottom = bottom->down;
				}
			}

			cu = cu->next;
		}
	}

	void queueAssign(queue<node*> &filteredQueue, queue<node*> &sortQueue, int &time) {
		queue<node*> tempQueue = filteredQueue;
		int cuTime = 0;
		cuTime = time;
		int tempTime = 0;

		while (!tempQueue.empty()) {
			if (tempQueue.front()->start == "START") {
				cuTime = tempQueue.front()->data;
				cout << "current time: " << cuTime << endl;
				sortQueue.push(tempQueue.front());
			}		

			else if (tempQueue.front()->start == "CORE" && tempQueue.front()->data >= cuTime) {
				tempTime += tempQueue.front()->data;
				sortQueue.push(tempQueue.front());
			}

			tempQueue.pop();
			cout << "not empty yet" << endl;
		}
		cout << "current time is: " << cuTime << endl;
		cout << "empty now" << endl;
	}
};

void showQueue(queue<node*> printQueue)
{
	queue<node*> popQueue = printQueue;
	while (!popQueue.empty())
	{
		cout << popQueue.front()->start << " " << popQueue.front()->data << " " << popQueue.front()->processID << " ";
		popQueue.pop();
	}
	cout << endl;
}

void startSimulation(eventList eventTable, queue<node*> filteredQueue, queue<node*> sortQueue, queue<node*> interactQueue, queue<node*> nonInteractQueue, int time) {
	eventTable.printList();
	eventTable.filterList(filteredQueue);
	eventTable.assignProcessID();
	showQueue(filteredQueue);
	eventTable.queueAssign(filteredQueue, sortQueue, time);
	showQueue(sortQueue);
}

int main() {

	string word;
	int value, numCores;
	int time = 0;
	eventList eventTable;

	ifstream inFile;
	inFile.open("myinput2.txt");
	while (inFile >> word >> value) {
		if (word == "NCORES") {
			numCores = value;
		}

		else {
			eventTable.storeEntry(word, value);
		}
	}

	queue<node*> filteredQueue;
	queue<node*> sortQueue;
	queue<node*> interactQueue;
	queue<node*> nonInteractQueue;

	startSimulation(eventTable, filteredQueue, sortQueue, interactQueue, nonInteractQueue, time);

	inFile.close();
	system("pause");
	return 0;
}
